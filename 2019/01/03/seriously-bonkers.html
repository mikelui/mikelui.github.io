<!DOCTYPE html>

<html>

  <head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Initialization in C++ is Seriously Bonkers - No TV and No Beer
    
  </title>

  <meta name="description" content="I was recently reminded of why I think it‚Äôs a bad idea to teach beginners C++. It‚Äôs a bad idea because it is an objective mess‚Äìalbeit a beautiful, twisted, t...">

  <link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,400i,700|Open+Sans:300,300i,700,800" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/vendor/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/assets/vendor/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">

  <link rel="canonical" href="http://mikelui.io/2019/01/03/seriously-bonkers.html">
  <link rel="alternate" type="application/rss+xml" title="No TV and No Beer" href="/feed.xml">

  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Initialization in C++ is Seriously Bonkers | No TV and No Beer</title>
<meta name="generator" content="Jekyll v3.6.2" />
<meta property="og:title" content="Initialization in C++ is Seriously Bonkers" />
<meta name="author" content="Mike Lui" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I was recently reminded of why I think it‚Äôs a bad idea to teach beginners C++. It‚Äôs a bad idea because it is an objective mess‚Äìalbeit a beautiful, twisted, tragic, wondrous mess. This is partly a follow-up on Simon Brand‚Äôs article, Initialization in C++ is bonkers, and partly a commentary on every student who‚Äôs wanted to begin their education by gazing into the abyss." />
<meta property="og:description" content="I was recently reminded of why I think it‚Äôs a bad idea to teach beginners C++. It‚Äôs a bad idea because it is an objective mess‚Äìalbeit a beautiful, twisted, tragic, wondrous mess. This is partly a follow-up on Simon Brand‚Äôs article, Initialization in C++ is bonkers, and partly a commentary on every student who‚Äôs wanted to begin their education by gazing into the abyss." />
<link rel="canonical" href="http://mikelui.io/2019/01/03/seriously-bonkers.html" />
<meta property="og:url" content="http://mikelui.io/2019/01/03/seriously-bonkers.html" />
<meta property="og:site_name" content="No TV and No Beer" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-03T00:00:00-05:00" />
<script type="application/ld+json">
{"headline":"Initialization in C++ is Seriously Bonkers","description":"I was recently reminded of why I think it‚Äôs a bad idea to teach beginners C++. It‚Äôs a bad idea because it is an objective mess‚Äìalbeit a beautiful, twisted, tragic, wondrous mess. This is partly a follow-up on Simon Brand‚Äôs article, Initialization in C++ is bonkers, and partly a commentary on every student who‚Äôs wanted to begin their education by gazing into the abyss.","datePublished":"2019-01-03T00:00:00-05:00","dateModified":"2019-01-03T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://mikelui.io/2019/01/03/seriously-bonkers.html"},"@type":"BlogPosting","url":"http://mikelui.io/2019/01/03/seriously-bonkers.html","author":{"@type":"Person","name":"Mike Lui"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

  
    <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top text-dark" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">No TV and No Beer</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/posts">Posts</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/guides">Guides</a>
        </li>
        <!--
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
        -->
      </ul>
    </div>
  </div>
</nav>

  

    <!-- Page Header -->

<header class="masthead no-bg">

  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <div class="post-heading">
          <h1>Initialization in C++ is Seriously Bonkers</h1>
          
          <h2 class="subheading">Footguns Galore</h2>
          
          
          <div class="border-top border-dark pb-3 col-8 mx-auto"></div>
          
          <span class="meta">Posted by
              <a href="#">Mike Lui</a>
            on January 03, 2019</span>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="container post">
  <div class="row">
    <div class="col-lg-8 col-md-10 mx-auto">

      <p class="lead">I was recently reminded of why I think it‚Äôs a bad idea to teach beginners C++.
It‚Äôs a bad idea because it is an objective mess‚Äìalbeit a beautiful, twisted, tragic, wondrous mess.
This is partly a follow-up on <a href="https://blog.tartanllama.xyz/">Simon Brand‚Äôs</a> article, <a href="https://blog.tartanllama.xyz/initialization-is-bonkers/">Initialization in C++ is bonkers</a>,
and partly a commentary on every student who‚Äôs wanted to begin their education by gazing into the abyss.</p>

<p>Here are some common remarks I get when students find out they‚Äôll be using C:</p>
<ul>
  <li><em>‚ÄúPeople still use C?‚Äù</em></li>
  <li><em>‚ÄúC is stupid.‚Äù</em></li>
  <li><em>‚ÄúWhy are we learning C?‚Äù</em></li>
  <li><em>‚ÄúWe should be learning something better like C++.‚Äù</em> (<strong><em>cue laugh track</em></strong>)</li>
</ul>

<p>Many students seem to think learning C is of little relevance (<strong><em>narrator:</em></strong> <em>it‚Äôs not</em>) and,
more relevant to this post, seem to think that they should instead start with C++.
Let‚Äôs investigate just one of the reasons this is an absurd suggestion: <strong><em>creating a frickin‚Äô variable.</em></strong>
In Simon Brand‚Äôs original article, he assumed the reader was already familiar with pre-C++11 initialization
oddities.
I‚Äôll introduce some of those here and go a bit beyond, too.</p>

<p>Let me preface by pointing out that, although I currently work for Drexel University‚Äôs Electrical and Computer Engineering department,
the thoughts and opinions in this post‚Äìand every post‚Äìare my own and <strong><em>not</em></strong> the university‚Äôs.
The classes I normally assist/instruct are part an engineering curriculum and not computer science,
and thus have different needs geared more towards embedded systems and systems programming.</p>

<h1 id="initialization-in-c">Initialization in C</h1>
<h3 id="prologue">Prologue</h3>

<p>First let‚Äôs look at initialization in C<sup id="fnref:c_init"><a href="#fn:c_init" class="footnote">1</a></sup>, since it‚Äôs similar to C++ for compatibility reasons.
This should go by fairly quick since C is so boring and simple (<em>ahem</em>).
Initialization is hammered into anyone new to the language because it acts rather differently in C than
in many newer statically typed languages, that will either default to sane values or provide 
compile time errors if used uninitialized.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Any C programmer worth anything knows that this initializes <code class="highlighter-rouge">i</code> to an indeterminate value
(for all intents and purposes, <code class="highlighter-rouge">i</code> is uninitialized).
Generally, it‚Äôs good practice to initialize variables <em>when they are defined</em>, e.g. <code class="highlighter-rouge">int i = 0;</code>,
and variables must always be initialized <em>before</em> they‚Äôre used.
No matter how many times we <del>repeat, shout, scream, badger</del> gently remind students about this,
there are still those who think it gets initialized to <code class="highlighter-rouge">0</code> by default.</p>

<p>Great, let‚Äôs try something else simple.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So this is obviously the same, right?
We have no idea what value <code class="highlighter-rouge">i</code> might have when we print‚Äìit could be anything.</p>

<p><em>Nope</em>.</p>

<p>Because <code class="highlighter-rouge">i</code> has static storage duration, it‚Äôs initialized to unsigned zero.
Why, you ask? Because the standard says so.
This has similar behavior for pointer types, which I‚Äôm not even going to address in this post.</p>

<p>O-kay, let‚Äôs look at structs.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Same deal. <code class="highlighter-rouge">a</code> is uninitialized.
We can see this if we compile with warnings.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gcc -Wuninitalized a.c
a.c: In function ‚Äòmain‚Äô:
a.c:9:5: warning: ‚Äòa.i‚Äô is used uninitialized in this function [-Wuninitialized]
     printf("%d\n", a.i);
</code></pre></div></div>

<p>In C, we can initialize our object a few straight-forward ways.
For example:
1) by using a helper function,
2) initializing during definition, or
3) assigning some default global value.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span> <span class="k">const</span> <span class="n">default_A</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">init_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">A</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* helper function */</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">a1</span><span class="p">;</span>
    <span class="n">init_A</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a1</span><span class="p">);</span>

    <span class="cm">/* during definition;
     * initialize each member, in order... */</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="cm">/* ...or allow members to be implicitly initialized,
     * which defaults to the value it would take during
     * static initialization (i.e. 0) */</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">a3</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="cm">/* ...or use designated initializers if C99 or later */</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">a4</span> <span class="o">=</span> <span class="p">{.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>

    <span class="cm">/* default value */</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">a5</span> <span class="o">=</span> <span class="n">default_A</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That‚Äôs pretty much it for C, and it‚Äôs enough to cause many tricksy bugs to manifest in many student projects.
It‚Äôs certainly enough to cause a minor headache deciding how to simply default everything to <code class="highlighter-rouge">0</code>.</p>

<h1 id="initialization-in-c-1">Initialization in C++</h1>
<h3 id="act-1-our-heros-journey-begins">Act 1: Our Hero‚Äôs Journey Begins</h3>

<p>If you‚Äôre eager to learn all the <del>terrors</del> wonders of C++, you should first learn how to initialize your variables.
All the same <em>behaviors</em> apply for C++ as in C for the previous code, with some caveats in the <em>rules</em>
for those behaviors.
C++-specific lingo will be <em>italicized</em> to emphasize when I‚Äôm not just arbitrarily naming things
and to emphasize how many more‚Ä¶<em>features</em>‚Ä¶C++ has compared to C.
Let‚Äôs start off with an easy one:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C++ has almost the same behavior as C here.
In C, this just creates an object of type <code class="highlighter-rouge">A</code> whose value could be anything.
In C++, <code class="highlighter-rouge">a</code> is <em>default initialized</em><sup id="fnref:default_init"><a href="#fn:default_init" class="footnote">2</a></sup>, meaning its <em>default constructor</em><sup id="fnref:default_constructor"><a href="#fn:default_constructor" class="footnote">3</a></sup> is used to construct it.
Because <code class="highlighter-rouge">A</code> is so trivial, it has an <em>implicitly-defined default constructor</em> which does nothing
in this case. The implicitly-defined default constructor <em>‚Äúhas exactly the same effect‚Äù</em> as:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">(){}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To check that we‚Äôre getting an uninitialized value, we can opt for a compile-time warning.
As of this post, I‚Äôve found that <code class="highlighter-rouge">g++ 8.2.1</code> provides good warnings, while <code class="highlighter-rouge">clang++ 7.0.1</code>
does not for this case (with <code class="highlighter-rouge">-Wuninitialized</code>).
Note that optimizations are turned on to catch some extra examples where variables would be uninitialized.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -Wuninitalized -O2 a.cpp
a.cpp: In function ‚Äòint main()‚Äô:
a.cpp:9:20: warning: ‚Äòa.A::i‚Äô is used uninitialized in this function [-Wuninitialized]
     std::cout &lt;&lt; a.i &lt;&lt; std::endl;
</code></pre></div></div>

<p>So in essence, this is as we‚Äôd expect coming from C.
So how do we initialize <code class="highlighter-rouge">A::i</code>?</p>

<h3 id="act-2-our-hero-stumbles">Act 2: Our Hero Stumbles</h3>

<p>Well, we could at least use the same ways as we did in C, right?
C++ is a superset of C, after all, right? (<em>ahem</em>)</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -Wuninitialized -O2 -pedantic-errors a.cpp
a.cpp: In function ‚Äòint main()‚Äô:
a.cpp:9:12: error: C++ designated initializers only available with -std=c++2a or -std=gnu++2a [-Wpedantic]
     A a = {.i = 0};
</code></pre></div></div>

<p>Well there goes the neighborhood.
Apparently designated initializers aren‚Äôt supported in C++ until C++20.
That is, the C++ standards targeted for 2020.
Yes, C++ is getting a feature 21 years after C.
Note that I‚Äôve added <code class="highlighter-rouge">-pedantic-errors</code> to remove support for non-standard gcc extensions.</p>

<p>What about this?</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -Wuninitialized -O2 -pedantic-errors a.cpp
</code></pre></div></div>

<p>Well at least that works.
As in C, we can also do <code class="highlighter-rouge">A a = {};</code> and it will have the same effect of zero-initializing <code class="highlighter-rouge">a.i</code>.
That‚Äôs because <code class="highlighter-rouge">A</code> is an <em>aggregate type</em><sup id="fnref:agg_init"><a href="#fn:agg_init" class="footnote">4</a></sup>.
What‚Äôs an aggregate type?</p>

<p>In <strong><em>pre-C++11</em></strong> world: an aggregate type is (essentially) either a simple C-style array,
or a struct that looks like a simple C struct.
No access specifiers, no base classes, no user-declared constructors, no virtual functions.
An aggregate type gets <em>aggregate initialized</em>.
What‚Äôs aggregate initialization?</p>

<ol>
  <li>Each member of the aggregate is initialized by each element of the braced list in order.</li>
  <li>Each member without a corresponding element braced list will get <em>value initialized</em><sup id="fnref:value_init"><a href="#fn:value_init" class="footnote">5</a></sup>.</li>
</ol>

<p>Great, what does that mean?
If the member is another class type with a user-provided constructor, it‚Äôll be called.
If the member is a class type without a user-provided constructor, like <code class="highlighter-rouge">A</code>, it‚Äôll be recursively value-initialized.
If the member is a built-in like our <code class="highlighter-rouge">int i</code>, then it‚Äôs <em>zero-initialized</em><sup id="fnref:zero_init"><a href="#fn:zero_init" class="footnote">6</a></sup>.</p>

<p>HooOOooOOrraay! We finally achieved a sort-of-default value of zero!  Whew.</p>

<p>In <strong><em>post-C++11</em></strong> world: ‚Ä¶we‚Äôll get to that later.</p>

<p>Does that seem hard to remember and confusing?
Note there‚Äôs a different set of rules for each version of C++.
<strong><em>It is. It‚Äôs frickin‚Äô confusing and no one likes it</em></strong>.
These rules are mostly in place so things act like you‚Äôd expect them to when you go to initialize something with nothing.
In practice, it‚Äôs best to explicitly initialize.
I‚Äôm not picking on aggregate initialization in its own right.
I‚Äôm picking on having to partake in a goose-chase through the standard to find out precisely what happens during initialization.</p>

<h3 id="act-3-our-hero-journeys-into-the-cave">Act 3: Our Hero Journeys Into the Cave</h3>

<p>Let‚Äôs use the C++ way to initialize <code class="highlighter-rouge">A</code>, with <strong>constructors</strong>! (<em>triumphant music</em>)
We can give <code class="highlighter-rouge">A</code>‚Äôs member, <code class="highlighter-rouge">i</code>, an initial value in a <em>user-provided</em> default constructor:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This initializes <code class="highlighter-rouge">i</code> in a <em>member initializer list</em><sup id="fnref:init_list"><a href="#fn:init_list" class="footnote">7</a></sup>.
A smellier way would be to set the value inside the constructor body:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Because the constructor body can pretty much do anything, it‚Äôs better to separate initialization into
the member initializer list (technically a part of the constructor body).</p>

<div class="bs-callout bs-callout-info">

  <p class="mt-0">In C++11 or later, we can use <em>default member initializers</em><sup id="fnref:default_member"><a href="#fn:default_member" class="footnote">8</a></sup> (seriously, just use these when you can).</p>
  <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// default member initializer, available in C++11 and later
</span><span class="p">};</span>
</code></pre></div>  </div>

</div>

<p>O-kay, now the default constructor ensures that <code class="highlighter-rouge">i</code> is set to 0 when any <code class="highlighter-rouge">A</code> is default initialized.
Finally, if we wanted to allow users of <code class="highlighter-rouge">A</code> to set <code class="highlighter-rouge">i</code>‚Äôs initial value, we could create another constructor just for that,
or alternatively mush them together using default arguments:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">a2</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -pedantic-errors -Wuninitialized -O2 a.cpp
$ ./a.out
0 1
</code></pre></div></div>

<div class="alert alert-info" role="alert">
  <i class="fa fa-info-circle"></i> <b>Note:</b> 
We can‚Äôt write <code class="highlighter-rouge">A a();</code> to call the default constructor because it gets parsed as:
a declaration of a function, named <code class="highlighter-rouge">a</code>, that takes no arguments and returns an <code class="highlighter-rouge">A</code> object.
Why? Because someone somewhere a long time ago wanted to allow function declarations in compound statement blocks,
and now we‚Äôre stuck with it.

</div>

<p>Great! That‚Äôs it. Mission accomplished. Roll credits.
You are now ready your adventures into C++ primed with your handy-dandy
C++ survival guide with instructions on initializing variables.
Turn around and be on your way!</p>

<h3 id="act-4-our-hero-continues-into-the-blackness">Act 4: Our Hero Continues Into the Blackness</h3>
<p>We <em>could</em> stop there.
But, if we want to use the <em>modern</em> features of <em>modern C++</em>, we have to delve further.
In fact the version of g++ I‚Äôve been using (8.2.1) uses <code class="highlighter-rouge">gnu++1y</code> by default, which equivalent to C++14 with some extra GNU extensions.
Even more, this version of g++ also fully supports C++17.
<em>‚ÄúDoes that matter?‚Äù</em> you might ask. Put on your fishing waders and wade with me yonder.</p>

<p>All versions following, and including, C++11, have this new-fangled way to initialize objects, called <em>list initialization</em><sup id="fnref:list_init"><a href="#fn:list_init" class="footnote">9</a></sup>.
Did anyone else feel a chill up their spine just now?
This is also referred to as <em>uniform initialization</em>.
There are some good reasons to use this syntax, covered <a href="https://isocpp.org/wiki/faq/cpp11-language-misc#cpp11-narrowing">here</a>
and <a href="https://isocpp.org/wiki/faq/cpp11-language#uniform-init">here</a>.
One amusing quote from the FAQ:</p>
<blockquote>
  <p>C++11 uniform initialization is not perfectly uniform, but it‚Äôs very nearly so.</p>
</blockquote>

<p>List initialization uses braces (<code class="highlighter-rouge">{thing1, thing2, ...}</code>, called a <em>braced-init-list</em>) and looks like this:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="cp">#include &lt;iostream&gt; 
</span><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">;</span>      <span class="c1">// default initialization -- as before
</span>    <span class="n">A</span> <span class="n">a2</span><span class="p">{};</span>    <span class="c1">// direct-list-initialization with empty list
</span>    <span class="n">A</span> <span class="n">a3</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// copy-list-initialization with empty list
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">a2</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">a3</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -std=c++11 -pedantic-errors -Wuninitialized -O2 a.cpp
a.cpp: In function ‚Äòint main()‚Äô:
a.cpp:9:26: warning: ‚Äòa1.A::i‚Äô is used uninitialized in this function [-Wuninitialized]
     std::cout &lt;&lt; a1.i &lt;&lt; " " &lt;&lt; a2.i &lt;&lt; " " &lt;&lt; a3.i ¬´ std::endl;
</code></pre></div></div>

<p><em>Whoa, whoa, whoa</em>. Did you catch that? Only <code class="highlighter-rouge">a1.i</code> is uninitialized.
Clearly, list initialization works differently than just calling a constructor.</p>

<p><code class="highlighter-rouge">A a{};</code> produces the same behavior as <code class="highlighter-rouge">A a = {};</code>.
In both, <code class="highlighter-rouge">a</code> is initialized with an empty braced-init-list.
Also, <code class="highlighter-rouge">A a = {};</code> isn‚Äôt called aggregate initialization anymore‚Äìnow it‚Äôs <em>copy-list-initialization</em> (<em>sigh</em>).
We already said that <code class="highlighter-rouge">A a;</code> creates an object with indeterminate value and calls the default constructor.</p>

<p>The following happens in lines 7/8 (remember, this is <strong><em>post-C++11</em></strong>):</p>
<ol>
  <li>List initialization of <code class="highlighter-rouge">A</code>, causes 2.</li>
  <li><em>aggregate initialization</em> because <code class="highlighter-rouge">A</code> is an <em>aggregate type</em>.</li>
  <li>Because the list is empty, all members are initialized by empty lists.
    <ol>
      <li><code class="highlighter-rouge">int i{}</code> leads to value initialization which initializes <code class="highlighter-rouge">i</code> to 0.</li>
    </ol>
  </li>
</ol>

<p>What if the list isn‚Äôt empty?</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span> 
    <span class="n">A</span> <span class="n">a2</span><span class="p">{{}};</span>
    <span class="n">A</span> <span class="n">a3</span><span class="p">{</span><span class="n">a1</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">a2</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">a3</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -std=c++11 -pedantic-errors -Wuninitialized -O2 a.cpp
</code></pre></div></div>

<p><code class="highlighter-rouge">a1.i</code> is initialized with <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">a2.i</code> is initialized with an empty list, and <code class="highlighter-rouge">a3</code> is copy constructed from <code class="highlighter-rouge">a1</code>.</p>

<p>Unfortunately, the definition of an aggregate has changed in every version since C++11,
although there is functionally no difference between C++17 and C++20 aggregates, so far.
Depending on which version of the C++ standard is used, something may or may not be an aggregate.
The trend is to be more permissive of what is considered an aggregate.
For example, public base classes are allowed in aggregates as of C++17, which in turn complicates the rules of aggregate initialization.
Everything is great!</p>

<p>How are you feeling? Do you need some water? Are your fists clenching? Maybe take a break, go outside.</p>

<h3 id="act-5-sanitys-requiem">Act 5: Sanity‚Äôs Requiem</h3>
<p>What happens if <code class="highlighter-rouge">A</code> isn‚Äôt an aggregate?</p>

<p>Quick recap, an aggregate is:</p>
<ul>
  <li>an array, or</li>
  <li>a struct/class/union with
    <ul>
      <li>no private/protected members</li>
      <li>no user-(provided/declared) constructors</li>
      <li>no virtual functions</li>
      <li>no default member initializers (in C++11, doesn‚Äôt matter for later)</li>
      <li>no base classes (public bases allowed in C++17)</li>
      <li>no inherited constructors (<code class="highlighter-rouge">using Base::Base;</code>, in C++17)</li>
    </ul>
  </li>
</ul>

<hr />

<p>So not-an-aggregate could be:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="cp">#include &lt;iostream&gt;
</span><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">(){};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -std=c++11 -pedantic-errors -Wuninitialized -O2 a.cpp
a.cpp: In function ‚Äòint main()‚Äô:
a.cpp:8:20: warning: ‚Äòa.A::i‚Äô is used uninitialized in this function [-Wuninitialized]
     std::cout &lt;&lt; a.i &lt;&lt; std::endl;
</code></pre></div></div>

<p>Here, <code class="highlighter-rouge">A</code> has a user-provided constructor so list initialization works differently.<br />
The following happens on line 8:</p>
<ol>
  <li>List initialization of <code class="highlighter-rouge">A</code>, causes 2.</li>
  <li>Non-aggregate with an empty braced-init-list causes value initialization, go to 3.</li>
  <li>A user-provided constructor was found, so the default constructor called which does nothing in this case.
<code class="highlighter-rouge">a.i</code> is uninitialized.</li>
</ol>

<hr />

<div class="bs-callout bs-callout-info">

  <p class="mt-0">What‚Äôs a user-provided constructor anyway?</p>

  <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>  </div>

  <p>The above is <em>not</em> a user-provided constructor.
It‚Äôs as if no constructor was declared at all and <code class="highlighter-rouge">A</code> is an aggregate.</p>

  <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">();</span>
<span class="p">};</span>
<span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</code></pre></div>  </div>
  <p>The above <em>is</em> a user-provided constructor.
It‚Äôs as if we wrote <code class="highlighter-rouge">A(){}</code> in the body and <code class="highlighter-rouge">A</code> is not an aggregate.</p>

  <p>Guess what, in C++20, the wording has changed to require aggregates to have no user-<em>declared</em> constructors üòä.
What does that mean in practice? I‚Äôm not sure! Let‚Äôs carry on.</p>

</div>

<hr />

<p>What about the following:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">int</span> <span class="n">main</span><span class="p">();</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">A</code> is a class, not a struct, so <code class="highlighter-rouge">i</code> is private, and we had to set <code class="highlighter-rouge">main</code> as a friend function.
That makes <code class="highlighter-rouge">A</code> not an aggregate. It‚Äôs just a normal class type.
That means <code class="highlighter-rouge">a.i</code> will be uninitialized, right?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ -std=c++11 -pedantic-errors -Wuninitialized -O2 a.cpp
</code></pre></div></div>

<p>Dangit. And just when we thought we were getting the hang of this.
Turns out <code class="highlighter-rouge">a.i</code> will be initialized to <code class="highlighter-rouge">0</code>, even though it doesn‚Äôt invoke aggregate initialization:</p>
<ol>
  <li>List initialization of <code class="highlighter-rouge">A</code>, causes 2.</li>
  <li>Non-aggregate, class type with a default constructor, and an empty braced-init-list causes value initialization, go to 3.</li>
  <li>No user-provided constructor found, so zero-initialize the object, go to 4.</li>
  <li>Invoke default-initialization if the implicitly-defined default constructor is non-trivial
(it is in this case so nothing is done).</li>
</ol>

<p>What if we tried to use aggregate initialize:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">int</span> <span class="n">main</span><span class="p">();</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -std=c++11 -pedantic-errors -Wuninitialized -O2 a.cpp
a.cpp: In function ‚Äòint main()‚Äô:
a.cpp:7:13: error: could not convert ‚Äò{1}‚Äô from ‚Äò&lt;brace-enclosed initializer list&gt;‚Äô to ‚ÄòA‚Äô
     A a = {1};
</code></pre></div></div>

<p><code class="highlighter-rouge">A</code> is <em>not</em> an aggregate, so the following happens:</p>
<ol>
  <li>List initialization of <code class="highlighter-rouge">A</code>, causes 2.</li>
  <li>Search for a matching constructor</li>
  <li>No way to convert a <code class="highlighter-rouge">0</code> to an <code class="highlighter-rouge">A</code>, compilation fails</li>
</ol>

<hr />

<p>One last example for good measure:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">(){}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -std=c++11 -pedantic-errors -Wuninitialized -O2 a.cpp
a.cpp: In function ‚Äòint main()‚Äô:
a.cpp:11:25: warning: ‚Äòb.B::&lt;anonymous&gt;.A::i‚Äô is used uninitialized in this function [-Wuninitialized]
     std::cout &lt;&lt; b.i &lt;&lt; " " &lt;&lt; b.j &lt;&lt; std::endl;
</code></pre></div></div>

<p><code class="highlighter-rouge">b.j</code> is initialized but <code class="highlighter-rouge">b.i</code> is uninitialized. What‚Äôs happening in this example?
I‚Äôm not sure! ü§∑
All of <code class="highlighter-rouge">b</code>‚Äôs bases and members <em>should</em> be getting zero-initialized here.
I‚Äôve asked about this on <a href="https://stackoverflow.com/questions/54028846/why-is-a-member-not-getting-zero-initialized-in-this-example">Stack Overflow</a>,
and as of publishing this post haven‚Äôt received a sufficient answer other than a possible compiler bug.
For comparison, clang‚Äôs static analyzer (not the normal compiler warnings) does not warn about uninitialized values.
Go figure.</p>

<p>‚Ä¶ (<em>blankly stares at you</em>) (<em>stare turns to polite smile</em>) alright let‚Äôs dive deeper!</p>

<h3 id="act-5-the-abyss">Act 5: The Abyss</h3>

<p>C++11 introduced something called a <code class="highlighter-rouge">std::initializer_list</code><sup id="fnref:initializer_list"><a href="#fn:initializer_list" class="footnote">10</a></sup>.
It has its own type, which is obviously <code class="highlighter-rouge">std::initializer_list&lt;T&gt;</code>.
You can create one with a braced-init-list.
Oh by the way, a braced-init-list, used in list initialization, that has <em>no type</em>.
Make sure you don‚Äôt confuse an initializer_list with list initialization or braced-init-lists!
And they are sorta related to member initializer lists and default member initializers,
in that they help initialize non-static data members, but are also quite different.
They are related but different! Easy, right?</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">A</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="n">A</span> <span class="n">a3</span><span class="p">{</span><span class="s">"hey"</span><span class="p">,</span> <span class="s">"thanks"</span><span class="p">,</span> <span class="s">"for"</span><span class="p">,</span> <span class="s">"reading!"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">a2</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">a3</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -std=c++17 -pedantic-errors -Wuninitialized -O2 a.cpp
a.cpp: In function ‚Äòint main()‚Äô:
a.cpp:12:21: warning: ‚Äòa1.A::i‚Äô is used uninitialized in this function [-Wuninitialized]
     std::cout &lt;&lt; a1.i &lt;&lt; a2.i &lt;&lt; a3.i &lt;&lt; std::endl;
                     ^
a.cpp:12:29: warning: ‚Äòa2.A::i‚Äô is used uninitialized in this function [-Wuninitialized]
     std::cout &lt;&lt; a1.i &lt;&lt; a2.i &lt;&lt; a3.i &lt;&lt; std::endl;
                             ^
a.cpp:12:37: warning: ‚Äòa3.A::i‚Äô is used uninitialized in this function [-Wuninitialized]
     std::cout &lt;&lt; a1.i &lt;&lt; a2.i &lt;&lt; a3.i &lt;&lt; std::endl;
</code></pre></div></div>

<p>O‚Äîkay. <code class="highlighter-rouge">A</code> has one templated constructor that takes a <code class="highlighter-rouge">std::initializer_list&lt;T&gt;</code>.
The user-provided constructor is called each time, which does nothing, so <code class="highlighter-rouge">i</code> remains uninitialized.
The type of <code class="highlighter-rouge">T</code> is deduced depending the elements in the list, and a new constructor is instantiated depending on the type.</p>
<ul>
  <li>So in line 8, <code class="highlighter-rouge">{0}</code> is deduced as a <code class="highlighter-rouge">std::initializer_list&lt;int&gt;</code> with one element, <code class="highlighter-rouge">0</code>.</li>
  <li>In line 9, <code class="highlighter-rouge">{1, 2, 3}</code> is deduced as a <code class="highlighter-rouge">std::initializer_list&lt;int&gt;</code> with three elements.</li>
  <li>In line 10, the braced-init-list is deduced as a <code class="highlighter-rouge">std::initializer_list&lt;const char*&gt;</code> with 4 elements.</li>
</ul>

<div class="alert alert-info" role="alert">
  <i class="fa fa-info-circle"></i> <b>Note:</b> 
<code class="highlighter-rouge">A a{}</code> will produce an error because a type cannot be deduced.
We would have to write <code class="highlighter-rouge">A a{std::initializer_list&lt;int&gt;{}}</code>, for example.
Or, we could exactly specify the constructor as in <code class="highlighter-rouge">A(std::initializer_list&lt;int&gt;){}</code>.

</div>

<p><code class="highlighter-rouge">std::initializer_list</code> acts kinda like a typical STL container,
but it only has three member functions: <code class="highlighter-rouge">size</code>, <code class="highlighter-rouge">begin</code>, and <code class="highlighter-rouge">end</code>.
<code class="highlighter-rouge">begin</code> and <code class="highlighter-rouge">end</code> return iterators you can dereference, increment, and compare normally.
This is useful when you want to initialize an object with varying length lists:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;string&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v_1_int</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v_5_ints</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v_strs</span> <span class="o">=</span> <span class="p">{</span><span class="s">"neato!"</span><span class="p">,</span> <span class="s">"blammo!"</span><span class="p">,</span> <span class="s">"whammo!"</span><span class="p">,</span> <span class="s">"egh"</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">vector</code> has a constructor that takes a <code class="highlighter-rouge">std::initializer_list&lt;T&gt;</code>, so we can easily initialize vectors as shown above.</p>
<div class="alert alert-info" role="alert">
  <i class="fa fa-info-circle"></i> <b>Note:</b> 
<code class="highlighter-rouge">v_1_int</code> is a vector created from its constructor taking a <code class="highlighter-rouge">std::initializer_list&lt;int&gt; init</code> with one element, <code class="highlighter-rouge">5</code>.<br />
<code class="highlighter-rouge">v_5_ints</code> is a vector created from its constructor taking a <strong><code class="highlighter-rouge">size_t count</code></strong>, which initializes a vector of count (<code class="highlighter-rouge">5</code>) elements and value-initializes them (all set to <code class="highlighter-rouge">0</code> in this case).

</div>

<p>Okie‚Äìdokie, one last example:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="cp">#include &lt;iostream&gt;
</span><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">{};</span>
    <span class="n">A</span> <span class="n">a3</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">A</span> <span class="n">a4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">};</span>
    <span class="n">A</span> <span class="n">a5</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>
              <span class="o">&lt;&lt;</span> <span class="n">a2</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>
              <span class="o">&lt;&lt;</span> <span class="n">a3</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>
              <span class="o">&lt;&lt;</span> <span class="n">a4</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>
              <span class="o">&lt;&lt;</span> <span class="n">a5</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p>At first glance, this isn‚Äôt too complicated.
We have two constructors, one that takes a <code class="highlighter-rouge">std::initializer_list&lt;int&gt;</code> and another with default arguments taking an <code class="highlighter-rouge">int</code>.
Before you look below at the output, try to figure out what will be the value for each <code class="highlighter-rouge">i</code>.</p>

<p class="pb-5">Thought about it‚Ä¶? Let‚Äôs see what we get.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ -std=c++11 -pedantic-errors -Wuninitialized -O2 a.cpp
$ ./a.out
1 1 3 2 2
</code></pre></div></div>

<p><code class="highlighter-rouge">a1</code> should have been easy. This is simple default initialization, which chooses the default constructor using its default arguments.
<code class="highlighter-rouge">a2</code> uses list initialization with an empty list.
Because <code class="highlighter-rouge">A</code> has a default constructor (with default arguments), value initialization occurs which just calls that constructor.
If <code class="highlighter-rouge">A</code> didn‚Äôt have that constructor, then the constructor on line 3 would be called with an empty list.
<code class="highlighter-rouge">a3</code> uses parenthesis, not a braced-init-list, so the overload resolution matches <code class="highlighter-rouge">3</code> with the constructor taking an <code class="highlighter-rouge">int</code>.
<code class="highlighter-rouge">a4</code> uses list initialization, which overload resolution will more favorably match with a constructor taking a <code class="highlighter-rouge">std::initializer_list</code>.
<code class="highlighter-rouge">a5</code> obviously can‚Äôt match against a single <code class="highlighter-rouge">int</code>, so the same constructor as <code class="highlighter-rouge">a4</code> is used.</p>

<h3 id="epilogue">Epilogue</h3>
<p>Hopefully you‚Äôve realized this post is (<em>mostly</em>) tongue-in-cheek and hopefully a bit informative, too.
Many of the peculiarities described in this post can be ignored and the language will act as you‚Äôd expect
if you remember to initialize your variables before use and initialize your data members during construction.
Knowing all of the corner cases of C++ is not necessary to write competent code, and you will otherwise learn
common pitfalls and idioms along the way.</p>

<p>The point I‚Äôve hopefully gotten across is that C++ is a big, crusty language (for many historical reasons).
This entire post was a rabbit hole on initialization rules.
<em>Just initializing variables</em>.
And we didn‚Äôt even cover all of it.
This post briefly covers 5 types of initialization.
Simon mentions in his <a href="https://blog.tartanllama.xyz/initialization-is-bonkers/">original post</a> that he found 18 types of initialization.</p>

<p>C++ is not a language I‚Äôd want to teach beginners.
At no point in this post was there room for systems programming concepts, discourse on programming paradigms,
computational-oriented problem solving methodologies, or fundamental algorithms.
If you are interested in C++ then feel free to take a class specifically on C++,
but know that the class will probably be specifically on learning C++.</p>

<p>C is a great, focused, fast, widely-supported, and widely-used language for solving problems across a variety of domains.
And it doesn‚Äôt have at least 18 types of initialization.</p>

<div class="footnotes">
  <ol>
    <li id="fn:c_init">
      <p><a href="https://en.cppreference.com/w/c/language/initialization">C initialization</a>¬†<a href="#fnref:c_init" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:default_init">
      <p><a href="https://en.cppreference.com/w/cpp/language/default_initialization">Default initialization</a>¬†<a href="#fnref:default_init" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:default_constructor">
      <p><a href="https://en.cppreference.com/w/cpp/language/default_constructor">Default constructors</a>¬†<a href="#fnref:default_constructor" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:agg_init">
      <p><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate initialization</a>¬†<a href="#fnref:agg_init" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:value_init">
      <p><a href="https://en.cppreference.com/w/cpp/language/value_initialization">Value initialization</a>¬†<a href="#fnref:value_init" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:zero_init">
      <p><a href="https://en.cppreference.com/w/cpp/language/zero_initialization">Zero initialization</a>¬†<a href="#fnref:zero_init" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:init_list">
      <p><a href="https://en.cppreference.com/w/cpp/language/initializer_list">Member initializer lists</a>¬†<a href="#fnref:init_list" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:default_member">
      <p><a href="https://en.cppreference.com/w/cpp/language/data_members#Member_initialization">Default member initializers</a>¬†<a href="#fnref:default_member" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:list_init">
      <p><a href="https://en.cppreference.com/w/cpp/language/list_initialization">List initialization</a>¬†<a href="#fnref:list_init" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:initializer_list">
      <p><a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code class="highlighter-rouge">std::initializer_list</code></a>¬†<a href="#fnref:initializer_list" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>


      <hr>

      <div class="clearfix">

        
        <a class="btn btn-primary float-left" href="/2018/07/22/jekyll-nested-blocks.html" data-toggle="tooltip" data-placement="top" title="Creating an Accordion Plugin for Jekyll">&larr; Previous<span class="d-none d-md-inline"> Post</span></a>
        
        

      </div>

    </div>
  </div>
</div>


    <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          
          
          <li class="list-inline-item">
            <a href="https://github.com/mikelui">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
            
            <li class="list-inline-item">
              <a href="https://linkedin.com/in/mikelui">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
              </span>
              </a>
            </li>
            
            
            <li class="list-inline-item">
              <a href="mailto:mikelui@drexel.edu">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
                                
            
            <li class="list-inline-item">
              <a href="http://vlsi.ece.drexel.edu/index.php?title=Michael_Lui">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-flask fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
                                
        </ul>
        <p class="copyright text-muted">Copyright &copy; Mike Lui 2019</p>
      </div>
    </div>
  </div>
</footer>


    <script src="/assets/vendor/jquery/jquery.min.js"></script>
<script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/clean-blog.min.js"></script>
<script src="/assets/js/scripts.js"></script>






  </body>

</html>
